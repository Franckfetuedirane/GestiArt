from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status, permissions
from django.db.models import Sum, Count, F
from artisans.models import Artisan
from produits.models import Produit
from ventes.models import Vente
from users.permissions import IsAdminUser, IsSecondaryAdminUser

class StatsView(APIView):
    """
    API endpoint to retrieve general statistics for the GestiArt application.
    Accessible by Admin and Secondary Admin users.

    Returns:
    - total_artisans: Total number of artisans.
    - active_products: Number of products with stock greater than 0.
    - total_sales_global: Total revenue from all sales.
    - total_revenue: Total revenue (same as total_sales_global).
    - sales_by_artisan: List of sales aggregated by artisan, ordered by total sales.
    - top_selling_products: List of top 5 selling products by quantity.
    """
    permission_classes = [IsAdminUser | IsSecondaryAdminUser]

    def get(self, request, format=None):
        """
        Handles GET requests to retrieve various statistics.
        """
        total_artisans = Artisan.objects.count()
        active_products = Produit.objects.filter(stock__gt=0).count()
        total_sales_global = Vente.objects.aggregate(total_sum=Sum(F('quantity') * F('unit_price')))['total_sum'] or 0
        total_revenue = total_sales_global

        sales_by_artisan = Vente.objects.values('artisan__first_name', 'artisan__last_name')\
                                       .annotate(total_sales=Sum(F('quantity') * F('unit_price')))\
                                       .order_by('-total_sales')

        top_selling_products = Vente.objects.values('product__name')\
                                        .annotate(total_quantity_sold=Sum('quantity'))\
                                        .order_by('-total_quantity_sold')[:5]

        data = {
            'total_artisans': total_artisans,
            'active_products': active_products,
            'total_sales_global': total_sales_global,
            'total_revenue': total_revenue,
            'sales_by_artisan': list(sales_by_artisan),
            'top_selling_products': list(top_selling_products),
        }
        return Response(data, status=status.HTTP_200_OK)

class ReportCardView(APIView):
    """
    API endpoint to generate a tabular report card for all artisans, their products, and sales.
    Accessible by Admin and Secondary Admin users.

    Returns a list of dictionaries, where each dictionary represents a row in the report table.
    Each row contains:
    - artisan_name: Full name of the artisan.
    - speciality: Artisan's speciality.
    - product_name: Name of the product.
    - product_category: Category of the product.
    - product_price: Price of the product.
    - product_stock: Current stock of the product.
    - total_sales_for_product: Total quantity sold for this product.
    - revenue_for_product: Total revenue generated by this product.
    """
    permission_classes = [IsAdminUser | IsSecondaryAdminUser]

    def get(self, request, format=None):
        """
        Handles GET requests to generate the report card.
        """
        report_data = []
        artisans = Artisan.objects.all()

        for artisan in artisans:
            products = Produit.objects.filter(artisan=artisan)
            if not products.exists():
                report_data.append({
                    'artisan_name': f'{artisan.first_name} {artisan.last_name}',
                    'speciality': artisan.speciality,
                    'product_name': 'N/A',
                    'product_category': 'N/A',
                    'product_price': 0,
                    'product_stock': 0,
                    'total_sales_for_product': 0,
                    'revenue_for_product': 0,
                })
                continue

            for product in products:
                sales_for_product = Vente.objects.filter(product=product)
                total_quantity_sold = sales_for_product.aggregate(Sum('quantity'))['quantity__sum'] or 0
                revenue_for_product = sales_for_product.aggregate(total_revenue=Sum(F('quantity') * F('unit_price')))['total_revenue'] or 0

                report_data.append({
                    'artisan_name': f'{artisan.first_name} {artisan.last_name}',
                    'speciality': artisan.speciality,
                    'product_name': product.name,
                    'product_category': product.category,
                    'product_price': product.price,
                    'product_stock': product.stock,
                    'total_sales_for_product': total_quantity_sold,
                    'revenue_for_product': revenue_for_product,
                })
        
        return Response(report_data, status=status.HTTP_200_OK)

# stats/views.py
# from rest_framework.views import APIView
# from rest_framework.response import Response
# from rest_framework import status
# from rest_framework.permissions import IsAuthenticated, IsAdminUser
# from django.db.models import Sum, F, Count
# from artisans.models import Artisan
# from produits.models import Produit
# from ventes.models import Vente, LigneVente
# from django.utils import timezone
# from datetime import timedelta

# class IsSecondaryAdminUser(IsAdminUser):
#     """
#     Permission personnalis√©e pour les administrateurs secondaires.
#     """
#     def has_permission(self, request, view):
#         return super().has_permission(request, view) or (
#             request.user and 
#             request.user.is_authenticated and 
#             hasattr(request.user, 'user_type') and
#             request.user.user_type == 'secondary_admin'
#         )

# class StatsView(APIView):
#     """
#     API endpoint to retrieve general statistics for the GestiArt application.
#     Accessible by Admin and Secondary Admin users.
#     """
#     permission_classes = [IsAuthenticated, IsAdminUser | IsSecondaryAdminUser]

#     def get(self, request, format=None):
#         try:
#             # 1. Statistiques de base
#             total_artisans = Artisan.objects.count()
#             active_products = Produit.objects.filter(stock__gt=0).count()
            
#             # 2. Calcul du chiffre d'affaires total
#             total_sales_global = 0
#             for vente in Vente.objects.all():
#                 for ligne in vente.lignes_vente.all():
#                     total_sales_global += ligne.quantity * ligne.unit_price

#             # 3. Ventes par artisan
#             sales_by_artisan = []
#             for artisan in Artisan.objects.all():
#                 total_ventes = 0
#                 for vente in Vente.objects.filter(artisan=artisan):
#                     for ligne in vente.lignes_vente.all():
#                         total_ventes += ligne.quantity * ligne.unit_price
                
#                 sales_by_artisan.append({
#                     'artisan_id': artisan.id,
#                     'artisan_name': f"{artisan.prenom} {artisan.nom}",
#                     'total_sales': float(total_ventes)
#                 })

#             # 4. Produits les plus vendus
#             from collections import defaultdict
#             product_sales = defaultdict(int)
            
#             for vente in Vente.objects.all():
#                 for ligne in vente.lignes_vente.all():
#                     product_sales[ligne.product] += ligne.quantity
            
#             top_products = []
#             for product, quantity in sorted(product_sales.items(), key=lambda x: x[1], reverse=True)[:5]:
#                 top_products.append({
#                     'product_id': product.id,
#                     'product_name': product.nom,
#                     'total_sold': quantity,
#                     'revenue': float(quantity * product.prix)
#                 })

#             # 5. Statistiques mensuelles
#             months = []
#             sales_data = []
#             today = timezone.now()
            
#             for i in range(5, -1, -1):  # 6 derniers mois
#                 month = today - timedelta(days=30*i)
#                 month_start = month.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
#                 next_month = (month_start + timedelta(days=32)).replace(day=1)
                
#                 month_sales = 0
#                 for vente in Vente.objects.filter(
#                     date_vente__gte=month_start,
#                     date_vente__lt=next_month
#                 ):
#                     for ligne in vente.lignes_vente.all():
#                         month_sales += ligne.quantity * ligne.unit_price
                
#                 months.append(month.strftime('%b %Y'))
#                 sales_data.append(float(month_sales))

#             return Response({
#                 'total_artisans': total_artisans,
#                 'active_products': active_products,
#                 'total_sales_global': float(total_sales_global),
#                 'total_revenue': float(total_sales_global),
#                 'sales_by_artisan': sales_by_artisan,
#                 'top_selling_products': top_products,
#                 'monthly_sales': {
#                     'labels': months,
#                     'data': sales_data
#                 }
#             })

#         except Exception as e:
#             import traceback
#             traceback.print_exc()
#             return Response(
#                 {'error': str(e), 'details': 'Erreur lors du calcul des statistiques'},
#                 status=status.HTTP_500_INTERNAL_SERVER_ERROR
#             )